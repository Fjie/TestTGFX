name: Coordinator Workflow

# 监听 PR 事件的触发类型，包括新建、同步和重新打开 PR
on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  poll_workflows:
    runs-on: ubuntu-latest

    steps:
      # 步骤 1：初始化变量
      - name: Initialize Variables
        id: vars
        run: |
          # 获取 PR 编号
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV

          # 获取仓库所有者和名称
          echo "REPO_OWNER=${{ github.repository_owner }}" >> $GITHUB_ENV
          echo "REPO_NAME=${GITHUB_REPOSITORY##*/}" >> $GITHUB_ENV

          # 获取 PR 标题并设置为 EVENT_TITLE
          echo "EVENT_TITLE=$(jq --raw-output .pull_request.title $GITHUB_EVENT_PATH)" >> $GITHUB_ENV

          # 设置 Webhook Key（建议在仓库 Secrets 中存储完整的 Webhook URL 或仅存储 Key）
          echo "WECHAT_WEBHOOK_KEY=${{ secrets.WECHAT_WEBHOOK_KEY }}" >> $GITHUB_ENV

          # 设置轮询参数
          echo "MAX_ATTEMPTS=30" >> $GITHUB_ENV            # 最大尝试次数（例如 30 次 ~ 30 分钟）
          echo "SLEEP_DURATION=60" >> $GITHUB_ENV         # 每次轮询的等待时间（秒）

          # 设置需要排除的工作流名称（即协调工作流本身）
          echo "EXCLUDE_WORKFLOW=Coordinator Workflow" >> $GITHUB_ENV

      # 步骤 2：安装必要的依赖工具
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      # 步骤 3：轮询检查工作流状态
      - name: Poll Workflow Status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
          REPO_OWNER: ${{ env.REPO_OWNER }}
          REPO_NAME: ${{ env.REPO_NAME }}
          WECHAT_WEBHOOK_KEY: ${{ env.WECHAT_WEBHOOK_KEY }}
          MAX_ATTEMPTS: ${{ env.MAX_ATTEMPTS }}
          SLEEP_DURATION: ${{ env.SLEEP_DURATION }}
          EXCLUDE_WORKFLOW: ${{ env.EXCLUDE_WORKFLOW }}
        run: |
          attempt=0
          success=true  # 假设开始时所有工作流都成功
          failure=false
          declare -A WORKFLOW_STATUS

          # 获取所有与此 PR 关联的 workflow runs
          runs=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/runs?pull_requests=$PR_NUMBER&per_page=100")

          # 提取所有相关工作流的名称，排除协调工作流自身
          workflows=$(echo "$runs" | jq -r --arg EXCLUDE "$EXCLUDE_WORKFLOW" '
            .workflow_runs[] 
            | select(.name != $EXCLUDE) 
            | .name
            ' | sort | uniq)

          # 如果没有获取到任何工作流名称，提示用户手动指定
          if [ -z "$workflows" ]; then
            echo "未能自动检测到与 PR 关联的工作流名称。请手动指定工作流名称。"
            exit 1
          fi

          echo "自动检测到以下工作流需要监控："
          echo "$workflows"

          # 将工作流名称保存到文件中，以便后续步骤使用
          echo "$workflows" > workflows.txt

          while [ $attempt -lt $MAX_ATTEMPTS ]; do
            echo "检查工作流状态，尝试次数：$((attempt+1))/${MAX_ATTEMPTS}"

            # 初始化轮循时的标志
            all_success=true
            any_failure=false

            # 读取工作流名称并检查每个工作流的状态
            while IFS= read -r workflow; do
              # 获取最新的 workflow run 状态
              workflow_run=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/runs?pull_requests=$PR_NUMBER&per_page=1&workflow_name=${workflow}")

              conclusion=$(echo "$workflow_run" | jq -r '.workflow_runs[0].conclusion // "null"')

              echo "Workflow \"$workflow\" 状态: $conclusion"

              if [[ "$conclusion" == "success" ]]; then
                # 工作流成功，无需更改标志
                :
              elif [[ "$conclusion" == "failure" || "$conclusion" == "cancelled" ]]; then
                any_failure=true
                all_success=false
              elif [[ "$conclusion" == "null" ]]; then
                # 工作流尚未完成
                all_success=false
              else
                # 其他结论状态，如 "timed_out", "action_required" 等
                all_success=false
              fi
            done < workflows.txt

            # 根据当前工作流状态决定下一步动作
            if [ "$all_success" = true ]; then
              echo "所有工作流都已成功完成。"
              break
            elif [ "$any_failure" = true ]; then
              echo "检测到至少一个工作流失败。"
              failure=true
              break
            else
              echo "部分工作流尚未完成。等待 $SLEEP_DURATION 秒后重试。"
              sleep $SLEEP_DURATION
              attempt=$((attempt+1))
            fi
          done

          # 准备发送通知的变量
          REPO_FULL_NAME="${REPO_OWNER}/${REPO_NAME}"
          PR_URL="https://github.com/${REPO_FULL_NAME}/pull/${PR_NUMBER}"
          EVENT_TITLE="${{ env.EVENT_TITLE }}"

          # 根据轮询结果发送相应的通知
          if [ "$all_success" = true ]; then
            echo "发送成功完成的通知到 Webhook。"
            curl -X POST -H "Content-Type: application/json" \
              -d '{
                    "msgtype": "text",
                    "text": {
                      "content": "仓库 '"$REPO_FULL_NAME"' 的构建和测试已成功完成。\n标题: '"$EVENT_TITLE"'\n请及时合入: '"$PR_URL"'"
                    }
                  }' \
              "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=${WECHAT_WEBHOOK_KEY}"
          elif [ "$failure" = true ]; then
            echo "发送失败的通知到 Webhook。"
            curl -X POST -H "Content-Type: application/json" \
              -d '{
                    "msgtype": "text",
                    "text": {
                      "content": "仓库 '"$REPO_FULL_NAME"' 的构建或测试失败。\n标题: '"$EVENT_TITLE"'\n请检查详细日志: '"$PR_URL"'"
                    }
                  }' \
              "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=${WECHAT_WEBHOOK_KEY}"
          else
            echo "在最大尝试次数内未检测到工作流的完成状态。"
            # 可选：发送超时通知
            curl -X POST -H "Content-Type: application/json" \
              -d '{
                    "msgtype": "text",
                    "text": {
                      "content": "仓库 '"$REPO_FULL_NAME"' 的构建和测试检查超时。\n标题: '"$EVENT_TITLE"'\n请手动检查相关工作流。"
                    }
                  }' \
              "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=${WECHAT_WEBHOOK_KEY}"
            exit 1
          fi